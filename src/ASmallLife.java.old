package com.yuredd.asmalllife;
import com.badlogic.gdx.ApplicationListener;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.PerspectiveCamera;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Mesh;
import com.badlogic.gdx.graphics.GL11;
import com.badlogic.gdx.graphics.VertexAttribute;
import com.badlogic.gdx.graphics.g3d.loaders.obj.ObjLoader;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;

import com.bulletphysics.collision.broadphase.AxisSweep3;
import com.bulletphysics.collision.dispatch.CollisionConfiguration;
import com.bulletphysics.collision.dispatch.CollisionDispatcher;
import com.bulletphysics.collision.dispatch.CollisionObject;
import com.bulletphysics.collision.dispatch.DefaultCollisionConfiguration;
import com.bulletphysics.collision.shapes.BoxShape;
import com.bulletphysics.collision.shapes.CollisionShape;
import com.bulletphysics.collision.shapes.SphereShape;
import com.bulletphysics.dynamics.DiscreteDynamicsWorld;
import com.bulletphysics.dynamics.RigidBody;
import com.bulletphysics.dynamics.RigidBodyConstructionInfo;
import com.bulletphysics.dynamics.constraintsolver.SequentialImpulseConstraintSolver;
import com.bulletphysics.linearmath.DefaultMotionState;
import com.bulletphysics.linearmath.Transform;
import com.bulletphysics.util.ObjectArrayList;
import javax.vecmath.Vector3f;
import java.nio.FloatBuffer;
import com.sun.opengl.util.BufferUtil;

public class ASmallLife implements ApplicationListener
{

	DiscreteDynamicsWorld dynamicsWorld;
	ObjectArrayList<CollisionShape> collisionShapes = new ObjectArrayList<CollisionShape>();

	private static FloatBuffer floatBuffer = BufferUtil.newFloatBuffer(16);

	private PerspectiveCamera cam;
	private Mesh block;
	private Mesh level;
	private Mesh hero;
	private Mesh crate;

	private Texture leveltex;

	private float heroWidth = 0.5f;
	private float heroHeight = 1.5f;
	private float hhw = heroWidth /2;
	private float hhh = heroHeight /2;

	private float herox = 0f;
	private float heroy = 0f;
	private float heroz = 0f;

	private float cratex = 0f;
	private float cratey = 0f;
	private float cratez = 0f;

	private float[] blocksx = new float[10];
	private float[] blocksy = new float[10];
	private float[] blocksz = new float[10];
	private int totblocks = 0;

	private void handleInput() {

		float movex = 0f;
		float movey = 0f;
		float movez = 0f;
		float rotx = 0f;
		float roty = 0f;

    CollisionObject obj = dynamicsWorld.getCollisionObjectArray().getQuick(1);
    RigidBody body = RigidBody.upcast(obj);
    Transform trans = new Transform();
    body.getMotionState().getWorldTransform(trans);


		// rileva gli eventi di tastiera
		if(Gdx.input.isKeyPressed(Input.Keys.LEFT)) movex = 0.1f;
		if(Gdx.input.isKeyPressed(Input.Keys.RIGHT)) movex = -0.1f;
		if(Gdx.input.isKeyPressed(Input.Keys.DOWN)) movez = -0.1f;
		if(Gdx.input.isKeyPressed(Input.Keys.UP)) movez = 0.1f;

		body.applyImpulse(new Vector3f(movex,0f,movez), new Vector3f(0f,0f,0f));

	}

  public void addCrate(float x, float y, float z) {

		CollisionShape shape = new BoxShape(new Vector3f(1f, 1f, 1f));
		collisionShapes.add(shape);
    Transform shapeTransform = new Transform();
		float mass = 1f;
		Vector3f localInertia = new Vector3f(0, 0, 0);
		shape.calculateLocalInertia(mass, localInertia);
    shapeTransform.setIdentity();
    shapeTransform.origin.set(new Vector3f(0.f, 5f, 0.f));
		DefaultMotionState myMotionState = new DefaultMotionState(shapeTransform);
		RigidBodyConstructionInfo rbInfo = new RigidBodyConstructionInfo(
          mass, myMotionState, shape, localInertia);
		RigidBody body = new RigidBody(rbInfo);
		dynamicsWorld.addRigidBody(body);

	}

  @Override
  public void create() {


		CollisionConfiguration collisionConfiguration = new DefaultCollisionConfiguration();
		CollisionDispatcher dispatcher = new CollisionDispatcher(collisionConfiguration);
		Vector3f worldAabbMin = new Vector3f(-10000, -10000, -10000);
    Vector3f worldAabbMax = new Vector3f(10000, 10000, 10000);
    int maxProxies = 1024;
    AxisSweep3 overlappingPairCache = new AxisSweep3(worldAabbMin, worldAabbMax, maxProxies);
		SequentialImpulseConstraintSolver solver = new SequentialImpulseConstraintSolver();
		dynamicsWorld = new DiscreteDynamicsWorld(
        dispatcher, overlappingPairCache, solver,
        collisionConfiguration);

		//test pavimento
		CollisionShape groundShape = new BoxShape(new Vector3f(150.f, 1.f, 150.f));
		collisionShapes.add(groundShape);

    Transform groundTransform = new Transform();
    groundTransform.setIdentity();
    groundTransform.origin.set(new Vector3f(0.f, -1.f, 0.f));

		DefaultMotionState myMotionState = new DefaultMotionState(groundTransform);
		RigidBodyConstructionInfo rbInfo = new RigidBodyConstructionInfo(
          0f, myMotionState, groundShape, new Vector3f(0, 0, 0));
		RigidBody body = new RigidBody(rbInfo);

		dynamicsWorld.addRigidBody(body);

		//test eroe
		CollisionShape heroShape = new BoxShape(new Vector3f(1f, 1f, 1f));
		collisionShapes.add(heroShape);
    Transform heroTransform = new Transform();
		float mass = 1f;
		Vector3f localInertia = new Vector3f(0, 0, 0);
		heroShape.calculateLocalInertia(mass, localInertia);
    heroTransform.setIdentity();
    heroTransform.origin.set(new Vector3f(0.f, 5f, 0.f));
		DefaultMotionState myMotionState2 = new DefaultMotionState(heroTransform);
		RigidBodyConstructionInfo rbInfo2 = new RigidBodyConstructionInfo(
          mass, myMotionState2, heroShape, localInertia);
		RigidBody hbody = new RigidBody(rbInfo2);
		dynamicsWorld.addRigidBody(hbody);





		level = ObjLoader.loadObj(Gdx.files.internal("data/leveltest.obj").read(), true);
		leveltex = new Texture(Gdx.files.internal("data/textest.png"));

		hero = ObjLoader.loadObj(Gdx.files.internal("data/herotest.obj").read(), true);
		crate = ObjLoader.loadObj(Gdx.files.internal("data/objecttest.obj").read(), true);

		//creazione oggetti

		addCrate(5,-5f,2);
		addCrate(5.7f,-5f,2);
		addCrate(3,-5f,3);
		addCrate(4,-5f,2);

		block = new Mesh(true, 4, 4,
		 new VertexAttribute(Usage.Position, 3,"attr_position"),
		 new VertexAttribute(Usage.ColorPacked, 4, "attr_color"));

		block.setVertices(new float[] { -0.5f, -0.5f, 0, Color.toFloatBits(255, 0, 0, 255),
		                               0.5f, -0.5f, 0, Color.toFloatBits(255, 255, 0, 255),
                                   -0.5f, 0.5f, 0, Color.toFloatBits(255, 0, 255, 255),
                                   0.5f, 0.5f, 0, Color.toFloatBits(255, 255, 255, 255) });

		block.setIndices(new short[] { 0, 1, 2, 3 });

		GL11 gl = Gdx.graphics.getGL11(); 

		gl.glEnable(gl.GL_TEXTURE_2D);  
  }

	public void updatePhysics() {
		dynamicsWorld.stepSimulation(1.f / 100.f, 10);

      for (int j=dynamicsWorld.getNumCollisionObjects()-1; j>=1; j--)
      {
        CollisionObject obj = dynamicsWorld.getCollisionObjectArray().getQuick(j);
        RigidBody body = RigidBody.upcast(obj);
        if (body != null && body.getMotionState() != null) {
          Transform trans = new Transform();
          body.getMotionState().getWorldTransform(trans);
if(j == 1) {
					herox = trans.origin.x;
					heroy = trans.origin.y;
					heroz = trans.origin.z;

					cam.position.x = herox;
					cam.position.y = 8f;
					cam.position.z = heroz-10;
					cam.lookAt(herox,heroy,heroz);
} else if(j == 2) {
					cratex = trans.origin.x;
					cratey = trans.origin.y;
					cratez = trans.origin.z;
}
				}
      }
	}

  @Override
  public void render() {
		handleInput();
		updatePhysics();
		GL11 gl = Gdx.graphics.getGL11(); 
		gl.glEnable(gl.GL_DEPTH_TEST);
		gl.glEnable(gl.GL_BLEND);
		cam.update();
		cam.apply(gl);

		gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT);

		leveltex.bind();

		gl.glPushMatrix();
		level.render(gl.GL_TRIANGLES);
		gl.glPopMatrix();

/*
		gl.glPushMatrix();
		gl.glTranslatef(herox, heroy, heroz);
		hero.render(gl.GL_TRIANGLES);
		gl.glPopMatrix();
*/
float[] tmp = new float[16];

      for (int j=dynamicsWorld.getNumCollisionObjects()-1; j>=1; j--)
      {
        CollisionObject obj = dynamicsWorld.getCollisionObjectArray().getQuick(j);
        RigidBody body = RigidBody.upcast(obj);
        if (body != null && body.getMotionState() != null) {
          Transform trans = new Transform();
          body.getMotionState().getWorldTransform(trans);

		gl.glPushMatrix();

					trans.getOpenGLMatrix(tmp);
					floatBuffer.clear();
					floatBuffer.put(tmp).flip();
					gl.glMultMatrixf(floatBuffer);
if(j == 1) {
		hero.render(gl.GL_TRIANGLES);
} else {
		crate.render(gl.GL_TRIANGLES);
}
		gl.glPopMatrix();

				}
			}
  }

  @Override
  public void resume() {

  }
  
  @Override
  public void resize(int width, int height) {
		float aspectRatio = (float) width / (float) height;
		cam = new PerspectiveCamera(67, 2f * aspectRatio, 2f);
  }
  
  @Override
  public void pause() {

  }

  @Override
  public void dispose() {
  
  }




}

